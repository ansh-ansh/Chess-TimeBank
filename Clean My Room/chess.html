<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blitz Chess ‚Äî Online & Offline</title>
<style>
:root{--bg:#061018;--panel:#0d1a22;--accent:#ff6b35;--accent2:#ffaa00;--muted:#9fb3c8}
*{box-sizing:border-box}body{margin:0;font-family:Inter,Segoe UI,system-ui,Arial;background:linear-gradient(135deg,#02040a 0%,#081827 60%);color:#e6f3fb;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
.container{width:100%;max-width:1200px;border-radius:12px;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.title{font-weight:800;background:linear-gradient(90deg,var(--accent),var(--accent2));-webkit-background-clip:text;color:transparent;font-size:20px}
.subtitle{color:var(--muted);font-size:13px}
.controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:14px}
.card{background:var(--panel);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
select,input{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:inherit}
.btn{padding:10px 12px;border-radius:10px;border:none;cursor:pointer;font-weight:800}
.btn-primary{background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#081018}
.btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
.layout{display:grid;grid-template-columns:1fr 420px 1fr;gap:18px;align-items:start}
.player{padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.12));border:1px solid rgba(255,255,255,0.02)}
.pname{font-weight:900;color:var(--accent2);margin-bottom:6px}
.time{font-family:monospace;font-weight:900;font-size:20px;color:var(--accent)}
.bank{font-size:12px;color:var(--muted)}
.captured{min-height:36px;margin-top:8px}
.board-wrap{display:flex;flex-direction:column;align-items:center}
.chessboard{display:grid;grid-template-columns:repeat(8,64px);grid-template-rows:repeat(8,64px);border-radius:10px;overflow:hidden;border:4px solid rgba(255,170,0,0.08)}
.square{width:64px;height:64px;display:flex;align-items:center;justify-content:center;font-size:36px;cursor:pointer;position:relative;transition:all .12s}
.square.light{background:#f0d9b5}
.square.dark{background:#b58863}
.square.selected{outline:3px solid rgba(255,255,0,0.95)}
.square.last-move{box-shadow:inset 0 0 18px rgba(255,107,53,0.18)}
.square.capture::after{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:44px;height:44px;border-radius:50%;border:3px solid rgba(255,80,80,0.95)}
.dot{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:20px;height:20px;border-radius:50%;background:rgba(0,200,80,0.95)}
.piece.white{color:#fff;text-shadow:0 2px 4px rgba(0,0,0,0.6)}
.piece.black{color:#000;text-shadow:0 1px 0 rgba(255,255,255,0.12)}
.status{text-align:center;color:var(--muted);font-weight:700;margin-top:8px}
.move-history{max-height:200px;overflow:auto;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px;margin-top:12px}
.chat{display:flex;flex-direction:column;height:260px;background:rgba(0,0,0,0.08);border-radius:8px;padding:8px;gap:8px}
.chat-messages{flex:1;overflow:auto;padding:6px;background:rgba(0,0,0,0.04);border-radius:6px}
.chat-controls{display:flex;gap:6px}
.overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.65));z-index:9999}
.modal{background:#07131a;padding:18px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);text-align:center}
.result{display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.65));z-index:10000}
.result .card{background:#07131a;padding:18px;border-radius:10px;border:2px solid rgba(255,107,53,0.12);text-align:center}
@media(max-width:1050px){.layout{grid-template-columns:1fr;justify-items:center}.chessboard{transform:scale(.85)}}
.player.right {
        margin-left: 80px; /* Moves Player 2 further right */
    }
    #drawPrompt {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border: 2px solid black;
        z-index: 999;
        display: none;
    }
    .flipped {
        transform: rotate(180deg);
    }
    .flipped .square {
        transform: rotate(180deg);
    }
    .player-status {
        font-size: 11px;
        color: #ff6b35;
        margin-top: 4px;
        font-style: italic;
    }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div>
      <div class="title">Blitz Chess ‚Äî Time Banks</div>
      <div class="subtitle">Online (Firebase) ‚Äî Real-time moves, chat, AI, offline rotation</div>
    </div>
    <div style="font-size:12px;color:var(--muted)">Open same file on two devices for online play</div>
  </div>

  <div id="setup" class="controls">
    <div class="card">
      <label style="font-size:12px;color:var(--muted)">Mode</label><br>
      <select id="mode">
        <option value="human-offline">Human vs Human (Offline)</option>
        <option value="human-online">Human vs Human (Online)</option>
        <option value="ai">Human vs AI</option>
      </select>
    </div>
    
    <div id="wrap1" class="card">
      <label style="font-size:12px;color:var(--muted)">Your name</label><br>
      <input id="name1" placeholder="Your name" value="Player1">
    </div>

    <div id="wrap2" class="card">
      <label style="font-size:12px;color:var(--muted)">Opponent name (offline only)</label><br>
      <input id="name2" placeholder="Opponent name" value="Player2">
    </div>

    <div class="card">
      <label style="font-size:12px;color:var(--muted)">Time</label><br>
      <select id="timeControl"><option value="180">3:00</option><option value="300" selected>5:00</option><option value="600">10:00</option></select>
    </div>

    <div class="card">
      <button id="startBtn" class="btn btn-primary">Start Game</button>
    </div>
  </div>

  <div id="gameArea" class="layout" style="display:none">
    <div class="player left">
      <div class="pname" id="topPlayerLabel">Opponent</div>
      <div class="time" id="topPlayerTime">5:00</div>
      <div class="bank">Time bank: <span id="topPlayerBank">0:30</span></div>
      <div class="captured" id="topPlayerCaptured"></div>
      <div class="player-status" id="topPlayerStatus"></div>
    </div>

    <div class="board-wrap">
      <div id="chessboard" class="chessboard"></div>
      <div id="status" class="status">White to move</div>
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:center">
        <button class="btn btn-ghost" onclick="offerDraw()">Offer Draw</button>
        <button class="btn btn-ghost" onclick="resign()">Resign</button>
        <button class="btn btn-ghost" onclick="exitToSetup()">Back to Setup</button>
      </div>

      <div style="margin-top:14px;display:flex;gap:12px">
        <div style="width:240px">
          <div style="font-weight:800;color:var(--muted);margin-bottom:6px">Move History</div>
          <div id="moveHistory" class="move-history"></div>
        </div>

        <div style="width:180px">
          <div style="font-weight:800;color:var(--muted);margin-bottom:6px">Chat (online)</div>
          <div class="chat" id="chatBox">
            <div id="chatMessages" class="chat-messages"></div>
            <div class="chat-controls">
              <input id="chatInput" placeholder="Message" style="flex:1;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit">
              <button class="btn btn-primary" onclick="sendChat()">Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="player right">
      <div class="pname" id="bottomPlayerLabel">You</div>
      <div class="time" id="bottomPlayerTime">5:00</div>
      <div class="bank">Time bank: <span id="bottomPlayerBank">0:30</span></div>
      <div class="captured" id="bottomPlayerCaptured"></div>
      <div class="player-status" id="bottomPlayerStatus"></div>
    </div>
  </div>
</div>

<!-- Searching overlay -->
<div id="searchOverlay" class="overlay"><div class="modal"><div style="color:var(--accent2);font-weight:900;margin-bottom:6px">Searching for opponent...</div><div id="searchTimer" style="color:#cfe6f7">20</div><div style="margin-top:10px"><button class="btn btn-ghost" onclick="cancelSearch()">Cancel</button></div></div></div>

<!-- Result popup -->
<div id="result" class="result"><div class="card"><div id="resultTitle" style="font-weight:900;color:var(--accent2);margin-bottom:6px">Result</div><div id="resultText" style="color:#cfe6f7;margin-bottom:12px"></div><div style="display:flex;gap:8px;justify-content:center"><button class="btn btn-primary" onclick="playAgain()">Play Again</button><button class="btn btn-ghost" onclick="exitToSetup()">Change Settings</button></div></div></div>

<!-- Firebase modular SDK (app + database) -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
import { getDatabase, ref, set, get, onValue, onChildAdded, push, update, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";

/* ---------------------------
   FIREBASE CONFIG (your project)
   --------------------------- */
const firebaseConfig = {
  apiKey: "AIzaSyALsrpUGjO5xA1eRDXRRvLQoX7p8W22bSE",
  authDomain: "blitz-chess-5fe97.firebaseapp.com",
  databaseURL: "https://blitz-chess-5fe97-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "blitz-chess-5fe97",
  storageBucket: "blitz-chess-5fe97.firebasestorage.app",
  messagingSenderId: "949128165492",
  appId: "1:949128165492:web:e42c6622a538b5fdf9b921",
  measurementId: "G-XFXGYC519L"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
/* --------------------------- */

/* --- Chess basics --- */
const PIECES = {'K':'‚ôî','Q':'‚ôï','R':'‚ôñ','B':'‚ôó','N':'‚ôò','P':'‚ôô','k':'‚ôö','q':'‚ôõ','r':'‚ôú','b':'‚ôù','n':'‚ôû','p':'‚ôü'};
let board = [];
function resetBoard(){
  board = [
    ['r','n','b','q','k','b','n','r'],
    ['p','p','p','p','p','p','p','p'],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null],
    ['P','P','P','P','P','P','P','P'],
    ['R','N','B','Q','K','B','N','R']
  ];
}
resetBoard();

/* --- State --- */
const state = {
  clientId: 'c-' + Date.now() + '-' + Math.floor(Math.random()*10000),
  mode: 'human-offline',
  started: false,
  ended: false,
  roomId: null,
  isHost: false,
  myColor: null,
  currentPlayer: 'white',
  selected: null,
  lastMove: null,
  captured: {white:[], black:[]},
  whiteName: 'White',
  blackName: 'Black',
  whiteTime: 300,
  blackTime: 300,
  whiteBank: 30,
  blackBank: 30,
  pendingDrawOffer: null,
  opponentLeft: false,
  // Castling rights
  castling: {
    whiteK: true, whiteQ: true,
    blackK: true, blackQ: true
  }
};

/* --- UI refs --- */
const boardEl = document.getElementById('chessboard');
const moveHistoryEl = document.getElementById('moveHistory');
const chatMessagesEl = document.getElementById('chatMessages');

/* --- Render board --- */
function renderBoard(){
  boardEl.innerHTML = '';
  for (let r=0;r<8;r++){
    for (let c=0;c<8;c++){
      const sq = document.createElement('div');
      sq.className = 'square ' + ((r+c)%2===0 ? 'light' : 'dark');
      sq.dataset.r = r; sq.dataset.c = c;
      const p = board[r][c];
      if (p){
        const span = document.createElement('div');
        span.className = 'piece ' + (p === p.toUpperCase() ? 'white' : 'black');
        span.textContent = PIECES[p];
        sq.appendChild(span);
      }
      sq.onclick = ()=> onSquareClick(r,c);
      boardEl.appendChild(sq);
    }
  }
  if (state.lastMove){
    const f = document.querySelector(`[data-r="${state.lastMove.from.r}"][data-c="${state.lastMove.from.c}"]`);
    const t = document.querySelector(`[data-r="${state.lastMove.to.r}"][data-c="${state.lastMove.to.c}"]`);
    if (f) f.classList.add('last-move'); if (t) t.classList.add('last-move');
  }
  updateOrientation();
}

/* --- orientation & UI update --- */
function updateOrientation(){
  if (state.mode === 'human-offline'){
    if (state.currentPlayer === 'black'){ 
      boardEl.style.transform='rotate(180deg)'; 
      document.querySelectorAll('.piece').forEach(p=>p.style.transform='rotate(180deg)'); 
    }
    else { 
      boardEl.style.transform='rotate(0deg)'; 
      document.querySelectorAll('.piece').forEach(p=>p.style.transform='rotate(0deg)'); 
    }
  } else if (state.mode === 'human-online') {
    // Online: each player sees their own color at the bottom
    if (state.myColor === 'black') {
      boardEl.style.transform='rotate(180deg)'; 
      document.querySelectorAll('.piece').forEach(p=>p.style.transform='rotate(180deg)');
    } else {
      boardEl.style.transform='rotate(0deg)'; 
      document.querySelectorAll('.piece').forEach(p=>p.style.transform='rotate(0deg)');
    }
  } else {
    // AI mode: always white at bottom
    boardEl.style.transform='rotate(0deg)'; 
    document.querySelectorAll('.piece').forEach(p=>p.style.transform='rotate(0deg)');
  }
}

function updateUI(){
  // Updated UI logic for perspective-based display
  if (state.mode === 'human-online' && state.myColor) {
    // Show player's own name at bottom, opponent at top
    const myName = state.myColor === 'white' ? state.whiteName : state.blackName;
    const opponentName = state.myColor === 'white' ? state.blackName : state.whiteName;
    const myTime = state.myColor === 'white' ? state.whiteTime : state.blackTime;
    const opponentTime = state.myColor === 'white' ? state.blackTime : state.whiteTime;
    const myBank = state.myColor === 'white' ? state.whiteBank : state.blackBank;
    const opponentBank = state.myColor === 'white' ? state.blackBank : state.whiteBank;
    const myCaptured = state.myColor === 'white' ? state.captured.white : state.captured.black;
    const opponentCaptured = state.myColor === 'white' ? state.captured.black : state.captured.white;
    
    document.getElementById('bottomPlayerLabel').innerText = myName + ` (${state.myColor})`;
    document.getElementById('topPlayerLabel').innerText = opponentName + ` (${state.myColor === 'white' ? 'black' : 'white'})`;
    document.getElementById('bottomPlayerTime').innerText = formatTime(myTime);
    document.getElementById('topPlayerTime').innerText = formatTime(opponentTime);
    document.getElementById('bottomPlayerBank').innerText = formatTime(myBank);
    // Hide opponent's time bank from view
    document.getElementById('topPlayerBank').innerText = "??:??";
    document.getElementById('bottomPlayerCaptured').innerHTML = myCaptured.map(p=>`<span style="font-size:20px;margin:2px">${PIECES[p]}</span>`).join('');
    document.getElementById('topPlayerCaptured').innerHTML = opponentCaptured.map(p=>`<span style="font-size:20px;margin:2px">${PIECES[p]}</span>`).join('');
    
    // Show opponent left status
    if (state.opponentLeft) {
      document.getElementById('topPlayerStatus').innerText = 'Player has left the game';
    } else {
      document.getElementById('topPlayerStatus').innerText = '';
    }
    document.getElementById('bottomPlayerStatus').innerText = '';
  } else {
    // Offline or AI mode - use original labels
    document.getElementById('topPlayerLabel').innerText = state.blackName + (state.mode === 'ai' ? ' (AI)' : '');
    document.getElementById('bottomPlayerLabel').innerText = state.whiteName;
    document.getElementById('topPlayerTime').innerText = formatTime(state.blackTime);
    document.getElementById('bottomPlayerTime').innerText = formatTime(state.whiteTime);
    document.getElementById('topPlayerBank').innerText = formatTime(state.blackBank);
    document.getElementById('bottomPlayerBank').innerText = formatTime(state.whiteBank);
    document.getElementById('topPlayerCaptured').innerHTML = state.captured.black.map(p=>`<span style="font-size:20px;margin:2px">${PIECES[p]}</span>`).join('');
    document.getElementById('bottomPlayerCaptured').innerHTML = state.captured.white.map(p=>`<span style="font-size:20px;margin:2px">${PIECES[p]}</span>`).join('');
    document.getElementById('topPlayerStatus').innerText = '';
    document.getElementById('bottomPlayerStatus').innerText = '';
  }
  
  document.getElementById('status').innerText = state.ended ? 'Game ended' : `${state.currentPlayer === 'white' ? 'White' : 'Black'} to move`;
}

/* --- utility --- */
function formatTime(s){ const m=Math.floor(s/60); const sec=s%60; return `${m}:${String(sec).padStart(2,'0')}`; }
function ephemeral(txt){ const el=document.createElement('div'); el.innerText=txt; el.style.position='fixed'; el.style.left='50%'; el.style.top='50%'; el.style.transform='translate(-50%,-50%)'; el.style.background='linear-gradient(90deg,var(--accent),var(--accent2))'; el.style.color='#071018'; el.style.padding='8px 12px'; el.style.borderRadius='8px'; el.style.zIndex=9999; el.style.fontWeight='900'; document.body.appendChild(el); setTimeout(()=>el.remove(),1300); }

/* --- selection/dots --- */
function clearMarkers(){
  document.querySelectorAll('.square').forEach(s=>{
    s.classList.remove('selected','capture');
    s.dataset.dot = '0';
    const d = s.querySelector('.dot'); if (d) d.remove();
  });
  state.selected = null;
}
function selectPiece(r,c){
  clearMarkers();
  state.selected = {r,c};
  const el = document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
  if (el) el.classList.add('selected');
  for (let tr=0;tr<8;tr++) for (let tc=0;tc<8;tc++){
    if (isValidMoveComplete({r,c},{r:tr,c:tc})){
      const sq = document.querySelector(`[data-r="${tr}"][data-c="${tc}"]`);
      if (!sq) continue;
      if (board[tr][tc]){ sq.classList.add('capture'); sq.dataset.dot='1'; const d=document.createElement('div'); d.className='dot'; d.style.opacity='0.0'; sq.appendChild(d);} 
      else { const d=document.createElement('div'); d.className='dot'; sq.appendChild(d); sq.dataset.dot='1'; }
    }
  }
}

/* --- click handler --- */
function onSquareClick(r,c){
  if (!state.started || state.ended) return;
  // If online require move ownership
  if (state.mode === 'human-online' && state.myColor !== state.currentPlayer){
    ephemeral('Wait for opponent'); return;
  }
  // if AI and it's AI's turn block
  if (state.mode === 'ai' && state.currentPlayer === 'black') return;

  const piece = board[r][c];
  if (state.selected){
    const target = document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
    if (target && target.dataset.dot === '1'){
      const from = {r: state.selected.r, c: state.selected.c};
      const to = {r,c};
      if (isValidMoveComplete(from,to)){
        applyMove(from,to, state.mode === 'human-online');
      }
      clearMarkers(); return;
    } else {
      if (piece && isPlayerPiece(piece, state.currentPlayer)){
        clearMarkers(); selectPiece(r,c); return;
      }
      clearMarkers(); state.selected = null; return;
    }
  } else {
    if (piece && isPlayerPiece(piece, state.currentPlayer)){
      if (state.mode === 'human-online' && state.myColor !== state.currentPlayer){ ephemeral('Cannot move opponent pieces'); return; }
      selectPiece(r,c);
    }
  }
}

/* --- move validation --- */
function isPlayerPiece(piece, player){ if (!piece) return false; return player === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase(); }
function isValidMove(from,to){ const piece = board[from.r][from.c]; if (!piece) return false; const target = board[to.r][to.c]; if (target && isPlayerPiece(target, state.currentPlayer)) return false; const dx = to.c - from.c, dy = to.r - from.r; switch(piece.toLowerCase()){ case 'p': return pawnMove(from,to,piece); case 'r': return rookMove(from,to); case 'n': return knightMove(from,to); case 'b': return bishopMove(from,to); case 'q': return rookMove(from,to) || bishopMove(from,to); case 'k': return kingMove(from,to);} return false;}
function isValidMoveComplete(from,to){
  if (!isValidMove(from,to)) return false;
  const piece = board[from.r][from.c]; const cap = board[to.r][to.c];
  // simulate (including castling)
  const special = isCastleMove(from,to,piece) ? {castle:true} : null;
  // Save states
  const savedFrom = board[from.r][from.c];
  const savedTo = board[to.r][to.c];
  let savedRook = null;
  let rookFrom=null, rookTo=null;
  if (special){
    const cs = getCastleRookSquares(from,to,piece);
    if (cs){
      rookFrom = cs.rookFrom; rookTo = cs.rookTo;
      savedRook = board[rookFrom.r][rookFrom.c];
      board[rookTo.r][rookTo.c] = savedRook;
      board[rookFrom.r][rookFrom.c] = null;
    }
  }
  board[to.r][to.c] = savedFrom; board[from.r][from.c] = null;
  const would = isInCheck(state.currentPlayer);
  // restore
  board[from.r][from.c] = savedFrom; board[to.r][to.c] = savedTo;
  if (special && rookFrom && rookTo){
    board[rookFrom.r][rookFrom.c] = savedRook;
    board[rookTo.r][rookTo.c] = null;
  }
  return !would;
}
function pawnMove(from,to,piece){ const isWhite = piece === piece.toUpperCase(); const dir = isWhite ? -1 : 1; const start = isWhite ? 6 : 1; const dx = to.c - from.c, dy = to.r - from.r; if (dx === 0){ if (dy === dir && !board[to.r][to.c]) return true; if (from.r === start && dy === 2*dir && !board[to.r][to.c] && !board[from.r+dir][from.c]) return true; } else if (Math.abs(dx) === 1 && dy === dir && board[to.r][to.c]) return true; return false; }
function rookMove(from,to){ const dx = to.c - from.c, dy = to.r - from.r; if (dx!==0 && dy!==0) return false; return pathClear(from,to); }
function bishopMove(from,to){ const dx=Math.abs(to.c-from.c), dy=Math.abs(to.r-from.r); if (dx!==dy) return false; return pathClear(from,to); }
function knightMove(from,to){ const dx=Math.abs(to.c-from.c), dy=Math.abs(to.r-from.r); return (dx===2&&dy===1)||(dx===1&&dy===2); }
function kingMove(from,to){ const dx=Math.abs(to.c-from.c), dy=Math.abs(to.r-from.r); if (dx<=1 && dy<=1) return true; if (dx===2 && dy===0){ return isCastleMove(from,to, board[from.r][from.c]); } return false; }
function pathClear(from,to){ const stepC = Math.sign(to.c-from.c), stepR = Math.sign(to.r-from.r); let r = from.r+stepR, c = from.c+stepC; while (r !== to.r || c !== to.c){ if (board[r][c] !== null) return false; r += stepR; c += stepC; } return true; }

/* --- Castling helpers --- */
function isCastleMove(from,to,piece){
  if (!piece) return false;
  if (piece.toLowerCase() !== 'k') return false;
  if (from.r !== to.r) return false;
  const dx = to.c - from.c;
  if (Math.abs(dx) !== 2) return false;
  return canCastle(from, to, piece);
}
function getCastleRookSquares(from,to,piece){
  const color = piece === piece.toUpperCase() ? 'white' : 'black';
  const rank = color === 'white' ? 7 : 0;
  const dx = to.c - from.c;
  if (dx === 2){
    return { rookFrom: {r: rank, c: 7}, rookTo: {r: rank, c: 5} };
  } else if (dx === -2){
    return { rookFrom: {r: rank, c: 0}, rookTo: {r: rank, c: 3} };
  }
  return null;
}
function canCastle(from,to,piece){
  const color = piece === piece.toUpperCase() ? 'white' : 'black';
  const rights = state.castling;
  const rank = color === 'white' ? 7 : 0;
  if (color === 'white'){
    if (!rights.whiteK && !rights.whiteQ) return false;
    if (from.r !== 7 || from.c !== 4) return false;
  } else {
    if (!rights.blackK && !rights.blackQ) return false;
    if (from.r !== 0 || from.c !== 4) return false;
  }
  const dx = to.c - from.c;
  const kingside = dx === 2;
  const queenside = dx === -2;
  const rookFrom = kingside ? {r:rank, c:7} : {r:rank, c:0};
  const rookTo = kingside ? {r:rank, c:5} : {r:rank, c:3};
  if (kingside){
    if (color === 'white' && !rights.whiteK) return false;
    if (color === 'black' && !rights.blackK) return false;
  } else {
    if (color === 'white' && !rights.whiteQ) return false;
    if (color === 'black' && !rights.blackQ) return false;
  }
  const rookPiece = board[rookFrom.r][rookFrom.c];
  if (!rookPiece) return false;
  if (color === 'white' && rookPiece !== 'R') return false;
  if (color === 'black' && rookPiece !== 'r') return false;
  const step = Math.sign(rookFrom.c - from.c);
  for (let c = from.c + step; c !== rookFrom.c; c += step){
    if (board[from.r][c] !== null) return false;
  }
  const squaresToCheck = [];
  const sign = dx > 0 ? 1 : -1;
  squaresToCheck.push({r:from.r, c: from.c});
  squaresToCheck.push({r:from.r, c: from.c + sign});
  squaresToCheck.push({r:from.r, c: from.c + 2*sign});
  for (const sq of squaresToCheck){
    const savedFrom = board[from.r][from.c];
    const savedTarget = board[sq.r][sq.c];
    board[from.r][from.c] = null;
    board[sq.r][sq.c] = savedFrom;
    const attacked = isInCheck(color);
    board[from.r][from.c] = savedFrom;
    board[sq.r][sq.c] = savedTarget;
    if (attacked) return false;
  }
  return true;
}

/* --- attack / check detection --- */
function isInCheck(player){
  let kingPos = null;
  for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p = board[r][c]; if (p && p.toLowerCase()==='k' && isPlayerPiece(p, player)){ kingPos={r,c}; break; } if (kingPos) break; }
  if (!kingPos) return false;
  for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p = board[r][c]; if (p && !isPlayerPiece(p, player)){ if (canAttack({r,c}, kingPos, p)) return true; } }
  return false;
}
function canAttack(from,to,piece){ const dx = to.c - from.c, dy = to.r - from.r, adx = Math.abs(dx), ady = Math.abs(dy); switch(piece.toLowerCase()){ case 'p': { const isWhite = piece===piece.toUpperCase(); const dir = isWhite ? -1 : 1; return (dy===dir && Math.abs(dx)===1); } case 'r': return (dx===0 || dy===0) && pathClear(from,to); case 'n': return (adx===2&&ady===1)||(adx===1&&ady===2); case 'b': return (adx===ady) && pathClear(from,to); case 'q': return ((dx===0||dy===0)||(adx===ady)) && pathClear(from,to); case 'k': return adx<=1 && ady<=1; } return false; }

/* --- generate moves --- */
function getAllValidMoves(player){
  const arr=[];
  for (let fr=0;fr<8;fr++) for (let fc=0;fc<8;fc++){
    const p = board[fr][fc]; if (p && isPlayerPiece(p, player)){
      for (let tr=0;tr<8;tr++) for (let tc=0;tc<8;tc++){
        if (isValidMove({r:fr,c:fc},{r:tr,c:tc})){
          const cap = board[tr][tc];
          board[tr][tc] = p; board[fr][fc] = null;
          const would = isInCheck(player);
          board[fr][fc] = p; board[tr][tc] = cap;
          if (!would) arr.push({from:{r:fr,c:fc}, to:{r:tr,c:tc}});
        }
      }
    }
  }
  return arr;
}
function notation(piece, from, to, captured, special){
  const files='abcdefgh', ranks='87654321';
  if (special && special.castle){
    if (to.c === 6) return 'O-O';
    if (to.c === 2) return 'O-O-O';
  }
  let s='';
  if (piece.toLowerCase()!=='p') s+=piece.toUpperCase();
  if (captured){ if (piece.toLowerCase()==='p') s+=files[from.c]; s+='x'; }
  s+=files[to.c]+ranks[to.r];
  return s;
}

/* --- apply move locally and optionally broadcast (online) --- */
function applyMove(from,to,broadcast){
  const piece = board[from.r][from.c]; if (!piece) return;
  const movingColor = state.currentPlayer;
  const captured = board[to.r][to.c];
  let special = null;
  // handle castling
  if (isCastleMove(from,to,piece)){
    special = {castle:true};
    const cs = getCastleRookSquares(from,to,piece);
    if (cs){
      board[to.r][to.c] = piece;
      board[from.r][from.c] = null;
      const rookPiece = board[cs.rookFrom.r][cs.rookFrom.c];
      board[cs.rookTo.r][cs.rookTo.c] = rookPiece;
      board[cs.rookFrom.r][cs.rookFrom.c] = null;
      if (piece === 'K'){ state.castling.whiteK = state.castling.whiteQ = false; }
      if (piece === 'k'){ state.castling.blackK = state.castling.blackQ = false; }
    }
  } else {
    board[to.r][to.c] = piece; board[from.r][from.c] = null;
    if (piece === 'K'){ state.castling.whiteK = state.castling.whiteQ = false; }
    if (piece === 'k'){ state.castling.blackK = state.castling.blackQ = false; }
    if (piece === 'R'){
      if (from.r === 7 && from.c === 0) state.castling.whiteQ = false;
      if (from.r === 7 && from.c === 7) state.castling.whiteK = false;
    }
    if (piece === 'r'){
      if (from.r === 0 && from.c === 0) state.castling.blackQ = false;
      if (from.r === 0 && from.c === 7) state.castling.blackK = false;
    }
  }

  if (captured){
    if (captured === 'R'){ 
      if (to.r === 7 && to.c === 0) state.castling.whiteQ = false;
      if (to.r === 7 && to.c === 7) state.castling.whiteK = false;
    } else if (captured === 'r'){
      if (to.r === 0 && to.c === 0) state.castling.blackQ = false;
      if (to.r === 0 && to.c === 7) state.castling.blackK = false;
    }
  }

  state.lastMove = {from,to};
  if (captured){ if (movingColor === 'white') state.captured.white.push(captured); else state.captured.black.push(captured); }
  const bonus = calcBonus(piece,captured,from,to);
  if (bonus){
    if (movingColor === 'white'){
      state.whiteBank = Math.max(0, state.whiteBank + bonus);
    } else {
      state.blackBank = Math.max(0, state.blackBank + bonus);
    }
    if (bonus > 0) ephemeral('+'+bonus+'s bonus');
    else ephemeral(bonus+'s penalty');
  }
  const note = notation(piece,from,to, captured, special);
  appendMove(note, bonus);
  state.currentPlayer = state.currentPlayer === 'white' ? 'black' : 'white';
  updateUI(); renderBoard();

  const inCheck = isInCheck(state.currentPlayer);
  const hasMoves = getAllValidMoves(state.currentPlayer).length > 0;
  if (!hasMoves){ if (inCheck) endGame('checkmate', { winner: state.currentPlayer === 'white' ? 'Black' : 'White' }); else endGame('stalemate'); }
  else if (inCheck) setStatus(`${state.currentPlayer === 'white' ? 'White' : 'Black'} is in check!`, '#ff4444');
  else setStatus(`${state.currentPlayer === 'white' ? 'White' : 'Black'} to move`);

  if (state.mode === 'ai' && state.currentPlayer === 'black' && !state.ended) setTimeout(makeAIMove, 500);

  if (broadcast && state.mode === 'human-online' && state.roomId){
    const payload = { from, to, piece, capturedPiece: captured || null, by: state.clientId, byColor: movingColor, notation: note, bonus, ts: Date.now() };
    if (special && special.castle){
      const cs = getCastleRookSquares(from,to,piece);
      if (cs) payload.castle = { rookFrom: cs.rookFrom, rookTo: cs.rookTo };
    }
    const mref = push(ref(db, 'rooms/' + state.roomId + '/moves'));
    set(mref, payload);
    set(ref(db, 'rooms/' + state.roomId + '/lastMove'), payload);
    set(ref(db, 'rooms/' + state.roomId + '/meta/castling'), state.castling).catch(()=>{});
  }
}

function calcBonus(piece,captured,from,to){
  let bonus=0;
  if (captured) {
    const vals={'p':1,'n':3,'b':3,'r':5,'q':9};
    bonus += vals[captured.toLowerCase()] || 0;
  }
  // Only give bonus for captures or checks; penalty for other moves
  if (isInCheck(state.currentPlayer === 'white' ? 'black' : 'white')) {
    bonus += 3;
  }
  if (bonus === 0) {
    bonus = -1;
  }
  return bonus;
}
function appendMove(notation, bonus){
  const d = document.createElement('div'); d.style.padding='6px 0'; d.innerText = `${notation}${bonus? ' (+'+bonus+'s)':''}`;
  moveHistoryEl.appendChild(d); moveHistoryEl.scrollTop = moveHistoryEl.scrollHeight;
}
function setStatus(t,c){ const el=document.getElementById('status'); el.innerText=t; if (c) el.style.color=c; else el.style.color=''; }

/* --- timers --- */
let timerInt = null;
function startTimers(){ if (timerInt) clearInterval(timerInt); timerInt = setInterval(()=>{
    if (state.ended) return;
    if (state.currentPlayer === 'white'){ state.whiteTime--; if (state.whiteTime<=0){ if (state.whiteBank>0){ const t=Math.min(state.whiteBank,10); state.whiteTime += t; state.whiteBank -= t; } else endGame('time', { winner:'Black' }); } }
    else { state.blackTime--; if (state.blackTime<=0){ if (state.blackBank>0){ const t=Math.min(state.blackBank,10); state.blackTime += t; state.blackBank -= t; } else endGame('time', { winner:'White' }); } }
    updateUI();
  },1000);
}

/* --- AI: prefer captures / checks (1-ply) --- */
function makeAIMove(){
  const moves = getAllValidMoves('black'); if (!moves.length) return;
  let best = moves[0], bestScore=-Infinity;
  for (const m of moves){
    const score = scoreMoveForAI(m);
    if (score > bestScore){ bestScore = score; best = m; }
  }
  applyMove(best.from, best.to, false);
}
function scoreMoveForAI(move){
  const piece = board[move.from.r][move.from.c];
  const captured = board[move.to.r][move.to.c];
  let score = 0;
  if (captured){ const vals={'p':1,'n':3,'b':3,'r':5,'q':9}; score += (vals[captured.toLowerCase()]||0)*10; }
  if ((move.to.r===3||move.to.r===4) && (move.to.c===3||move.to.c===4)) score += 2;
  const savedFrom = board[move.from.r][move.from.c], savedTo = board[move.to.r][move.to.c];
  board[move.to.r][move.to.c]=savedFrom; board[move.from.r][move.from.c]=null;
  if (isInCheck('white')) score += 5;
  board[move.from.r][move.from.c]=savedFrom; board[move.to.r][move.to.c]=savedTo;
  return score;
}

/* --- draw & resign --- */
function offerDraw(){
  if (!state.started || state.ended) return;
  if (state.mode === 'ai'){ ephemeral('Draw not allowed vs AI'); return; }
  if (state.mode === 'human-offline'){ 
    if (confirm('Do both players on this device agree to a draw?')) endGame('draw'); 
    else ephemeral('Draw declined'); 
    return; 
  }
  if (state.roomId){
    if (state.pendingDrawOffer && state.pendingDrawOffer.from === state.clientId){
      ephemeral('Draw offer already sent');
      return;
    }
    const offer = {
      id: 'draw-' + Date.now() + '-' + Math.floor(Math.random()*10000),
      from: state.clientId,
      name: state.myColor === 'white' ? state.whiteName : state.blackName,
      fromColor: state.myColor,
      status: 'pending',
      ts: Date.now()
    };
    set(ref(db, 'rooms/' + state.roomId + '/meta/drawOffer'), offer)
      .then(()=> {
        state.pendingDrawOffer = offer;
        ephemeral('Draw offer sent');
      })
      .catch(()=> ephemeral('Failed to send draw offer'));
  }
}

function resign(){
  if (!state.started || state.ended) return;
  if (!confirm('Are you sure you want to resign?')) return;
  if (state.mode === 'human-offline'){ const whiteResigns = confirm('Did White resign? (OK=White, Cancel=Black)'); const winner = whiteResigns ? 'Black' : 'White'; endGame('resign',{winner}); return; }
  if (state.mode === 'human-online' && state.roomId){ set(ref(db, 'rooms/' + state.roomId + '/meta/resign'), { from: state.clientId, winner: (state.myColor === 'white' ? 'Black' : 'White'), ts: Date.now(), handled:false }); endGame('resign', { winner: (state.myColor === 'white' ? 'Black' : 'White') }); }
  if (state.mode === 'ai'){ endGame('resign',{ winner:'AI' }); }
}

/* --- end / play again / UI flows --- */
function endGame(type, info){
  state.ended = true; state.started = false; clearInterval(timerInt);
  const title = document.getElementById('resultTitle'), text = document.getElementById('resultText');
  if (type === 'checkmate'){ title.innerText = 'üèÜ CHECKMATE'; text.innerText = `${info.winner} wins by checkmate!`; }
  else if (type === 'time'){ title.innerText = '‚è∞ TIME'; text.innerText = `${info.winner} wins on time!`; }
  else if (type === 'resign'){ title.innerText = '‚öîÔ∏è RESIGNATION'; text.innerText = `${info.winner || 'Opponent'} won by resignation.`; }
  else if (type === 'stalemate'){ title.innerText = '‚öñÔ∏è STALEMATE'; text.innerText = 'Game ends in stalemate.'; }
  else if (type === 'draw'){ title.innerText = 'ü§ù DRAW'; text.innerText = 'Game drawn by agreement.'; }
  else if (type === 'disconnect'){ title.innerText = 'üîå OPPONENT LEFT'; text.innerText = `${info.winner || 'You'} won because opponent left the game.`; }
  else { title.innerText = 'Result'; text.innerText = type; }
  document.getElementById('result').style.display = 'flex';
}
function playAgain(){ 
  document.getElementById('result').style.display='none'; 
  resetBoard(); 
  moveHistoryEl.innerHTML=''; 
  state.captured={white:[],black:[]}; 
  state.currentPlayer='white'; 
  state.ended=false; 
  state.started=true; 
  state.pendingDrawOffer=null; 
  state.opponentLeft=false; 
  const tc=parseInt(document.getElementById('timeControl').value,10); 
  state.whiteTime=tc; state.blackTime=tc; 
  state.whiteBank=Math.max(30,Math.floor(tc/10)); state.blackBank=state.whiteBank; 
  state.castling = { whiteK:true, whiteQ:true, blackK:true, blackQ:true };
  renderBoard(); updateUI(); startTimers(); 
}

/* --- Chat --- */
function sendChat(){
  const txt = document.getElementById('chatInput').value.trim();
  if (!txt || !state.roomId) return;
  const who = state.myColor === 'white' ? state.whiteName : state.blackName;
  const cref = push(ref(db, 'rooms/' + state.roomId + '/chat'));
  set(cref, { from: state.clientId, name: who, text: txt, ts: Date.now() });
  document.getElementById('chatInput').value = '';
}
function appendChat(msg){ const d=document.createElement('div'); d.style.padding='6px 0'; d.innerText = `${msg.name}: ${msg.text}`; chatMessagesEl.appendChild(d); chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight; }

/* --- Firebase matchmaking & listeners --- */
let searchInterval = null;
let roomsListener = null;
let playersListener = null;
let movesListener = null;
let metaListener = null;
let chatListener = null;

async function startOnlineSearch(){
  const waitingRef = ref(db, 'waiting');
  try {
    const snap = await get(waitingRef);
    const val = snap.val();
    const selectedTime = parseInt(document.getElementById('timeControl').value, 10);
    
    if (!val){
      // create waiting entry (host)
      state.isHost = true;
      await set(waitingRef, { hostId: state.clientId, name: document.getElementById('name1').value || 'Player', time: selectedTime, ts: Date.now() });
      document.getElementById('searchOverlay').style.display = 'flex';
      let sec = 20; document.getElementById('searchTimer').innerText = sec;
      searchInterval = setInterval(()=>{
        sec--; document.getElementById('searchTimer').innerText = sec;
        if (sec<=0){ clearInterval(searchInterval); set(waitingRef, null); document.getElementById('searchOverlay').style.display='none'; alert("Couldn't find a player ‚Äî returning to home."); exitToSetup(); }
      },1000);

      roomsListener = onValue(ref(db, 'rooms'), (roomsSnap)=>{
        const rooms = roomsSnap.val();
        if (!rooms) return;
        for (const rid in rooms){
          const r = rooms[rid];
          if (r.hostId === state.clientId){
            clearInterval(searchInterval); set(waitingRef, null);
            if (roomsListener) roomsListener();
            connectToRoom(rid, true);
            break;
          }
        }
      });
    } else {
      if (val.time !== selectedTime) {
        ephemeral('Time control mismatch! Cannot join.');
        return;
      }
      const hostId = val.hostId;
      const hostName = val.name;
      const roomId = 'room-' + Date.now() + '-' + Math.floor(Math.random()*10000);
      const flip = Math.random() < 0.5;
      const hostColor = flip ? 'white' : 'black';
      const joinColor = flip ? 'black' : 'white';
      const players = {};
      players[hostId] = { name: hostName, color: hostColor, joinedAt: Date.now() };
      players[state.clientId] = { name: document.getElementById('name1').value || 'Player', color: joinColor, joinedAt: Date.now() };

      await set(ref(db, 'rooms/' + roomId), { hostId, roomId, players, createdAt: Date.now(), timeControl: selectedTime });
      await set(waitingRef, null);
      connectToRoom(roomId, false);
    }
  } catch (err){
    console.error(err); alert('Firebase error during matchmaking'); exitToSetup();
  }
}

async function connectToRoom(roomId, amHost){
  state.roomId = roomId; state.isHost = !!amHost; state.mode = 'human-online'; state.started = true; state.ended = false; state.pendingDrawOffer = null; state.opponentLeft = false;
  
  const playerRef = ref(db, 'rooms/' + roomId + '/players/' + state.clientId);
  const presenceRef = ref(db, 'rooms/' + roomId + '/presence/' + state.clientId);
  
  await set(presenceRef, { online: true, lastSeen: Date.now() });
  onDisconnect(presenceRef).set({ online: false, lastSeen: Date.now() });
  
  await set(playerRef, { name: document.getElementById('name1').value || 'Player', color: (amHost ? 'white' : 'black'), joinedAt: Date.now() });
  
  document.getElementById('setup').style.display = 'none'; document.getElementById('searchOverlay').style.display='none'; document.getElementById('gameArea').style.display='grid';
  renderBoard(); updateUI(); startTimers();
  attachRoomListeners(roomId);
}

function attachRoomListeners(roomId){
  playersListener = onValue(ref(db, 'rooms/' + roomId + '/players'), (snap)=>{
    const players = snap.val();
    if (!players) return;
    let w='White', b='Black';
    for (const pid in players){
      const pl = players[pid];
      if (pl.color === 'white') w = pl.name;
      if (pl.color === 'black') b = pl.name;
      if (pid === state.clientId) state.myColor = pl.color;
    }
    state.whiteName = w; state.blackName = b;
    updateUI(); renderBoard();
  });

  onValue(ref(db, 'rooms/' + roomId + '/presence'), (snap) => {
    const presence = snap.val();
    if (!presence) return;
    
    let opponentOnline = false;
    for (const pid in presence) {
      if (pid !== state.clientId && presence[pid].online) {
        opponentOnline = true;
        break;
      }
    }
    
    if (!opponentOnline && state.started && !state.ended) {
      state.opponentLeft = true;
      updateUI();
      setTimeout(() => {
        if (state.opponentLeft && !state.ended) {
          endGame('disconnect', { winner: state.myColor === 'white' ? state.whiteName : state.blackName });
        }
      }, 3000);
    }
  });

  movesListener = onChildAdded(ref(db, 'rooms/' + roomId + '/moves'), (snap)=>{
    const m = snap.val(); if (!m) return;
    if (m.by === state.clientId) return;
    const from = m.from, to = m.to;
    if (m.castle && m.castle.rookFrom && m.castle.rookTo){
      board[to.r][to.c] = m.piece;
      board[from.r][from.c] = null;
      const rf = m.castle.rookFrom, rt = m.castle.rookTo;
      board[rt.r][rt.c] = board[rf.r][rf.c];
      board[rf.r][rf.c] = null;
      if (m.piece === 'K'){ state.castling.whiteK = state.castling.whiteQ = false; }
      if (m.piece === 'k'){ state.castling.blackK = state.castling.blackQ = false; }
    } else {
      board[to.r][to.c] = m.piece; board[from.r][from.c] = null;
    }
    if (m.capturedPiece){
      if (m.byColor === 'white') state.captured.white.push(m.capturedPiece); else state.captured.black.push(m.capturedPiece);
      if (m.capturedPiece === 'R'){ if (to.r === 7 && to.c === 0) state.castling.whiteQ = false; if (to.r === 7 && to.c === 7) state.castling.whiteK = false; }
      if (m.capturedPiece === 'r'){ if (to.r === 0 && to.c === 0) state.castling.blackQ = false; if (to.r === 0 && to.c === 7) state.castling.blackK = false; }
    }
    state.lastMove = { from, to };
    state.currentPlayer = state.currentPlayer === 'white' ? 'black' : 'white';
    appendMove(m.notation || 'move', m.bonus || 0);
    updateUI(); renderBoard();
  });

  metaListener = onValue(ref(db, 'rooms/' + roomId + '/meta'), async (snap)=>{
    const meta = snap.val(); 
    if (!meta) return;

    if (meta.castling){
      state.castling = { ...state.castling, ...meta.castling };
    }
    
    const d = meta.drawOffer;
    if (d){
      if (d.status === 'pending' && d.from !== state.clientId){
        if (!state._lastSeenDraw || state._lastSeenDraw !== d.id){
          state._lastSeenDraw = d.id;
          const accept = confirm(d.name + ' offered a draw. Accept?');
          const newStatus = accept ? 'accepted' : 'declined';
          await update(ref(db, 'rooms/' + roomId + '/meta/drawOffer'), { status: newStatus, handledBy: state.clientId, handledAt: Date.now() });
          if (accept) {
            endGame('draw');
          } else {
            ephemeral('You declined draw');
          }
        }
      }
      if (d.from === state.clientId && d.status && d.status !== 'pending'){
        if (d.status === 'accepted'){
          ephemeral('Draw accepted by opponent');
          endGame('draw');
        } else if (d.status === 'declined'){
          ephemeral('Draw offer declined');
        }
        setTimeout(()=> remove(ref(db, 'rooms/' + roomId + '/meta/drawOffer')).catch(()=>{}), 800);
        state.pendingDrawOffer = null;
      }
    }

    if (meta.resign && !meta.resign.handled && meta.resign.from !== state.clientId){
      endGame('resign', { winner: meta.resign.winner || 'Opponent' });
      update(ref(db, 'rooms/' + roomId + '/meta/resign'), { handled: true }).catch(()=>{});
    }
  });

  chatListener = onChildAdded(ref(db, 'rooms/' + roomId + '/chat'), (snap)=>{
    const c = snap.val(); if (!c) return;
    appendChat(c);
  });
}

function cancelSearch(){
  set(ref(db, 'waiting'), null).catch(()=>{});
  document.getElementById('searchOverlay').style.display = 'none';
  if (searchInterval) { clearInterval(searchInterval); searchInterval = null; }
  if (roomsListener) { roomsListener(); roomsListener = null; }
  exitToSetup();
}

function exitToSetup(){
  if (state.roomId){
    set(ref(db, 'rooms/' + state.roomId + '/players/' + state.clientId), null).catch(()=>{});
    set(ref(db, 'rooms/' + state.roomId + '/presence/' + state.clientId), { online: false, lastSeen: Date.now() }).catch(()=>{});
  }
  if (roomsListener) { roomsListener(); roomsListener = null; }
  if (playersListener) { playersListener(); playersListener = null; }
  if (movesListener) { movesListener(); movesListener = null; }
  if (metaListener) { metaListener(); metaListener = null; }
  if (chatListener) { chatListener(); chatListener = null; }

  clearInterval(timerInt); timerInt = null;
  state.started=false; state.ended=false; state.roomId=null; state.isHost=false; state.myColor=null; state.pendingDrawOffer=null; state.opponentLeft=false;
  document.getElementById('gameArea').style.display='none'; document.getElementById('setup').style.display='flex';
  document.getElementById('searchOverlay').style.display='none'; document.getElementById('result').style.display='none';
  resetBoard(); moveHistoryEl.innerHTML=''; chatMessagesEl.innerHTML=''; state.captured={white:[], black:[]};
  state.castling = { whiteK:true, whiteQ:true, blackK:true, blackQ:true };
  updateUI(); renderBoard();
}

document.getElementById('mode').addEventListener('change', (e)=>{
  const m = e.target.value;
  if (m === 'human-online' || m === 'ai') document.getElementById('wrap2').style.display='none';
  else document.getElementById('wrap2').style.display='block';
});

document.getElementById('startBtn').addEventListener('click', async ()=>{
  const mode = document.getElementById('mode').value;
  const n1 = (document.getElementById('name1').value || 'Player1').trim();
  const n2 = (document.getElementById('name2').value || 'Player2').trim();
  const tc = parseInt(document.getElementById('timeControl').value,10);
  state.mode = mode;
  state.whiteTime = tc; state.blackTime = tc; state.whiteBank = Math.max(30, Math.floor(tc/10)); state.blackBank = Math.max(30, Math.floor(tc/10));
  resetBoard(); moveHistoryEl.innerHTML = ''; chatMessagesEl.innerHTML = ''; state.captured={white:[],black:[]}; state.currentPlayer='white'; state.ended=false; state.started=false; state.myColor=null; state.pendingDrawOffer=null; state.opponentLeft=false;
  state.castling = { whiteK:true, whiteQ:true, blackK:true, blackQ:true };
  if (mode === 'human-offline'){ state.whiteName = n1; state.blackName = n2; document.getElementById('setup').style.display='none'; document.getElementById('gameArea').style.display='grid'; state.started=true; renderBoard(); updateUI(); startTimers(); }
  else if (mode === 'ai'){ state.whiteName = n1; state.blackName = 'AI'; document.getElementById('setup').style.display='none'; document.getElementById('gameArea').style.display='grid'; state.started=true; renderBoard(); updateUI(); startTimers(); }
  else if (mode === 'human-online'){ document.getElementById('searchOverlay').style.display='flex'; startOnlineSearch(); }
});

document.getElementById('chatInput').addEventListener('keydown', (e)=>{ if (e.key === 'Enter') sendChat(); });

renderBoard(); updateUI();

/* --- Expose some functions for UI --- */
window.offerDraw = offerDraw;
window.resign = resign;
window.exitToSetup = exitToSetup;
window.cancelSearch = cancelSearch;
window.playAgain = playAgain;
window.sendChat = sendChat;

</script>
</body>
</html>
